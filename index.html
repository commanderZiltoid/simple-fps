<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <link rel="stylesheet" href="/css/custom.css" media="all"/>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.7/socket.io.min.js"></script>
        
    </head>
    <body>
        <div id="blocker">
            <div id="instructions">
<!--                <span style="font-size:40px">Basic WASD/Mouse Movement</span>
                <br/>
                <span style="font-size:30px">Click to start</span>
                <br />
                (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)-->
            </div>
        </div>




        <script src="/libs/three.js"></script>
        <script src="/libs/PointerLockControls.js"></script>
        
        
        <script src="/src/verify_pointerlock.js"></script>
        <script src="/src/TextureAnimator.js"></script>
<script>
// =============================================================================
//  Peer object
// =============================================================================
var Peer = function(netObj) {

    this.textures = {
        s:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/s.png'),
        se:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/se.png'),
        e:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/e.png'),
        ne:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/ne.png'),
        n:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/n.png'),
        nw:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/nw.png'),
        w:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/w.png'),
        sw:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/sw.png')
    };

    this.animations = {
        s:new TextureAnimator(this.textures.s, 4, 1, 4, 160),
        se:new TextureAnimator(this.textures.se, 4, 1, 4, 160),
        e:new TextureAnimator(this.textures.e, 4, 1, 4, 160),
        ne:new TextureAnimator(this.textures.ne, 4, 1, 4, 160),
        n:new TextureAnimator(this.textures.n, 4, 1, 4, 160),
        nw:new TextureAnimator(this.textures.nw, 4, 1, 4, 160),
        w:new TextureAnimator(this.textures.w, 4, 1, 4, 160),
        sw:new TextureAnimator(this.textures.sw, 4, 1, 4, 160)
    };

    this.billboard_mat = new THREE.MeshBasicMaterial({map: this.textures.n,  transparent:true});
    this.billboard_geom = new THREE.PlaneGeometry(14, 14, 1, 1);
    this.billboard = new THREE.Mesh(this.billboard_geom, this.billboard_mat);
    this.billboard.name = netObj.id + '_billboard';

    this.material = new THREE.MeshBasicMaterial({transparent:true, opacity:0.0});
    this.geometry = new THREE.PlaneGeometry(14, 14, 1, 1);
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.name = netObj.id + '_mesh';

    this.billboard.position.set(netObj.position.x,netObj.position.y,netObj.position.z);
    scene.add(this.billboard);

    this.mesh.position.set(netObj.position.x,netObj.position.y,netObj.position.z);
    scene.add(this.mesh);
    
    this.direction = '';

};

// =============================================================================
//  The Client.
// =============================================================================
var Client = function(){
  
    this.id = null;
    
    this.key_left = false;
    this.key_right = false;
    this.key_up = false;
    this.key_down = false;
    this.jump = false;
    
    this.peers = new Object;
    
        
};

Client.prototype.processInputs = function(){
    if (controlsEnabled) {

        velocity.x -= velocity.x * 10.0 * dt;
        velocity.z -= velocity.z * 10.0 * dt;
        velocity.y -= 9.8 * 100.0 * dt; // 100.0 = mass

        if ( this.key_up ) velocity.z -= 400.0 * dt;
        if ( this.key_down ) velocity.z += 400.0 * dt;
        if ( this.key_left ) velocity.x -= 400.0 * dt;
        if ( this.key_right ) velocity.x += 400.0 * dt;

        controls.getObject().translateX( velocity.x * dt );
        controls.getObject().translateY( velocity.y * dt );
        controls.getObject().translateZ( velocity.z * dt );

        if ( controls.getObject().position.y < 10 ) {
                velocity.y = 0;
                controls.getObject().position.y = 10;
                this.jump = true;
        }

    }
};

// Find the position each player is facing relative to
// the current player camera position and display the 
// correct texture on the player billboard, animate texture
Client.prototype.animatePeers = function(){
    
    var animation_speed = 1000 * dt;
    
    for(var peer_id in this.peers){
        
        var peer = this.peers[peer_id];
        
        var a = new THREE.Vector3();
        a.subVectors(controls.getObject().position, peer.mesh.position);
        a.normalize();

        var b = new THREE.Vector3(0,0,1);
        b.applyQuaternion(peer.mesh.quaternion);
        b.normalize();

        var theta = Math.acos(a.dot(b)) * (180/Math.PI);
        if(a.x * a.z < 0){
            theta = 360.0 - theta;
        }
        
        //console.log(theta);
        
        if((theta > 0 && theta <= 22.5) || (theta > 337.5 && theta <= 359.99)){//south
            peer.direction = 'south';
            peer.billboard.material.map = peer.textures.s;
            peer.billboard.needsUpdate = true;
            peer.animations.s.update(animation_speed);
        }
        else if(theta > 292.5 && theta <= 337.5){//south east
            peer.direction = 'south east';
            peer.billboard.material.map = peer.textures.se;
            peer.billboard.needsUpdate = true;
            peer.animations.se.update(animation_speed);
        }
        else if((theta < 292.5 && theta >= 270) || (theta > 90 && theta <= 112.5)){//east
            peer.direction = 'east';
            peer.billboard.material.map = peer.textures.e;
            peer.billboard.needsUpdate = true;
            peer.animations.e.update(animation_speed);
        }
        else if(theta > 112.5 && theta <= 157.5){//northeast
            peer.direction = 'northeast';
            peer.billboard.material.map = peer.textures.ne;
            peer.billboard.needsUpdate = true;
            peer.animations.ne.update(animation_speed);
        }
        else if(theta > 157.5 && theta <= 202.5){//north
            peer.direction = 'north';
            peer.billboard.material.map = peer.textures.n;
            peer.billboard.needsUpdate = true;
            peer.animations.n.update(animation_speed);
        }
        else if(theta > 202.5 && theta <= 247.5){//northwest
            peer.direction = 'northwest';
            peer.billboard.material.map = peer.textures.nw;
            peer.billboard.needsUpdate = true;
            peer.animations.nw.update(animation_speed);
        }
        else if((theta > 67.5 && theta <= 89.99) || (theta > 247.5 && theta <= 269.99)){//west
            peer.direction = 'west';
            peer.billboard.material.map = peer.textures.w;
            peer.billboard.needsUpdate = true;
            peer.animations.w.update(animation_speed);
        }
        else if(theta > 22.5 && theta <= 67.5){//southwest
            peer.direction = 'southwest';
            peer.billboard.material.map = peer.textures.sw;
            peer.billboard.needsUpdate = true;
            peer.animations.sw.update(animation_speed);
        }

        peer.billboard.lookAt(controls.getObject().position);

    }
};

Client.prototype.updatePosition = function(netObj){
    
    controls.getObject().position.x = netObj.position.x;
    controls.getObject().position.y = netObj.position.y;
    controls.getObject().position.z = netObj.position.z;
    
};

Client.prototype.update = function(){

    this.animatePeers();
    this.processInputs();

};

</script>
<script>
    
    // =============================================================================
    //  Globals
    // =============================================================================
    var camera, 
        scene, 
        renderer,
        geometry,
        material,
        mesh,
        controls,
        blocker = document.getElementById( 'blocker' ),
        instructions = document.getElementById( 'instructions' ),
        controlsEnabled = false,
        prevTime = performance.now(),
        velocity = new THREE.Vector3(),
        clock = new THREE.Clock();

    var t = 0.0;
    var dt = 0.01;
    var currentTime = (+new Date()) / 1000.0;
    var accumulator = 0.0;



    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);

    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xffffff, 0, 750);

    var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
    light.position.set(0.5, 1, 0.75);
    scene.add(light);

    controls = new THREE.PointerLockControls(camera);
    scene.add(controls.getObject());


    //FLOOR
    geometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
    geometry.rotateX( - Math.PI / 2 );
    for (var i = 0, l = geometry.vertices.length; i < l; i ++) {
        var vertex = geometry.vertices[ i ];
        vertex.x += Math.random() * 20 - 10;
        vertex.y += Math.random() * 2;
        vertex.z += Math.random() * 20 - 10;
    }
    for (var i = 0, l = geometry.faces.length; i < l; i ++) {
        var face = geometry.faces[ i ];
        face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
    }
    material = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    //END FLOOR

    // Create renderer
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0xffffff);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);




    var client = new Client();
    //client.addPeer({id:'test_id'});

    var socket = io('http://local.three.js:3000');//change the domain to yours
    
    socket.on('successful_connection', function(netObj){
        
        client.id = netObj.id;
        client.updatePosition(netObj);

        // Run the main game loop as fast as we can
        setInterval(function(){
            mainLoop();
        }, 0);

    });
    
    socket.on('new_player_connection', function(netObj){
        if(netObj.id !== client.id){

            client.peers[netObj.id] = new Peer(netObj);
        
        }
    });
    
    socket.on('connected_players', function(netObj){
        for(var id in netObj){
            if(id !== client.id){
                client.peers[id] = new Peer(netObj[id]);
            }
        }
    });
    

    function mainLoop(){  
        
        var newTime = (+new Date()) / 1000.0;
        var frameTime = ((newTime - currentTime) > 0.25) ? 0.25 : (newTime - currentTime);
        currentTime = newTime;

        accumulator += frameTime;
        while(accumulator >= dt){

            client.update();

            //this.previous_x = this.current_x;

            t += dt;
            accumulator -= dt;       

        }

        //var alpha = accumulator / dt;

        // Interpolate position of client object
        //this.render_x = this.lerp(this.current_x, this.previous_x, alpha); 
        //this.render_x = this.current_x;

        
        renderer.render(scene, camera);
        
    }
        


    function testFunction(){
        
//        mesh = client.peers['test_id'].mesh;
//        mesh_quat = mesh.quaternion;
//        
//        mesh.quaternion.set(0, mesh_quat.y + .05, 0, mesh_quat.w + .05);
//        
//        console.log(mesh_quat);
        
        //console.log(client.peers['test_id'].mesh.rotation.y);
        //console.log(client.peers['test_id'].direction);
        
        //client.peers['test_id'].mesh.rotateY(.5);

        
        //console.log('Pressed Enter...');
        //console.log(client.peers['test_id'].mesh.quaternion);
        //console.log(controls.getObject().position);
        //console.log(controls.getObject().quaternion);
        //console.log(client.peers['test_id'].mesh.rotation);
        //console.log(controls.getObject().quaternion.w);
        
        console.log(controls.getDirection());

        
    }
</script>
        

<script src="/src/key_controls.js"></script>
<script src="/src/window_resize.js"></script>
        
</body>
</html>