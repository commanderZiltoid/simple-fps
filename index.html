<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <link rel="stylesheet" href="/css/custom.css" media="all"/>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.7/socket.io.min.js"></script>
        
    </head>
    <body>
        <div id="blocker">
            <div id="instructions">
<!--                <span style="font-size:40px">Basic WASD/Mouse Movement</span>
                <br/>
                <span style="font-size:30px">Click to start</span>
                <br />
                (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)-->
            </div>
        </div>




        <script src="/libs/three.js"></script>
        <script src="/libs/PointerLockControls.js"></script>
        
        
        <script src="/src/verify_pointerlock.js"></script>
        <script src="/src/TextureAnimator.js"></script>
<script>
// =============================================================================
//  Message queue.
// =============================================================================
var Queue = function() {
    this.updates = [];
};

Queue.prototype.send = function(update) {
    this.updates.push({recv_ts: +new Date(),payload:update});
};

Queue.prototype.receive = function() {
  for (var i = 0; i < this.updates.length; i++) {
      var update = this.updates[i];
      this.updates.splice(i, 1);
      return update;
  }
};

// =============================================================================
//  Peer object
// =============================================================================
var Peer = function(netObj) {

    this.textures = {
        s:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/s.png'),
        se:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/se.png'),
        e:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/e.png'),
        ne:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/ne.png'),
        n:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/n.png'),
        nw:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/nw.png'),
        w:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/w.png'),
        sw:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/sw.png')
    };

    this.animations = {
        s:new TextureAnimator(this.textures.s, 4, 1, 4, 160),
        se:new TextureAnimator(this.textures.se, 4, 1, 4, 160),
        e:new TextureAnimator(this.textures.e, 4, 1, 4, 160),
        ne:new TextureAnimator(this.textures.ne, 4, 1, 4, 160),
        n:new TextureAnimator(this.textures.n, 4, 1, 4, 160),
        nw:new TextureAnimator(this.textures.nw, 4, 1, 4, 160),
        w:new TextureAnimator(this.textures.w, 4, 1, 4, 160),
        sw:new TextureAnimator(this.textures.sw, 4, 1, 4, 160)
    };

    this.billboard_mat = new THREE.MeshBasicMaterial({map: this.textures.n,  transparent:true});
    this.billboard_geom = new THREE.PlaneGeometry(14, 14, 1, 1);
    this.billboard = new THREE.Mesh(this.billboard_geom, this.billboard_mat);
    this.billboard.name = netObj.id + '_billboard';

    this.material = new THREE.MeshBasicMaterial({transparent:true, opacity:0.0});
    this.geometry = new THREE.PlaneGeometry(14, 14, 1, 1);
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.name = netObj.id + '_mesh';

    this.billboard.position.set(netObj.position.x,netObj.position.y,netObj.position.z);
    scene.add(this.billboard);

    this.mesh.position.set(netObj.position.x,netObj.position.y,netObj.position.z);
    scene.add(this.mesh);
    
    this.direction = '';

};

Peer.prototype.updatePosition = function(netObj){
    
    this.billboard.position.x = netObj.position.x;
    this.billboard.position.y = netObj.position.y;
    this.billboard.position.z = netObj.position.z;
    
    this.mesh.position.x = netObj.position.x;
    this.mesh.position.y = netObj.position.y;
    this.mesh.position.z = netObj.position.z;
    
    
    this.mesh.quaternion.set(netObj.quat.x, netObj.quat.y, netObj.quat.z, netObj.quat.w);

    
    this.mesh.rotation.x = netObj.rot.x;
    this.mesh.rotation.y = netObj.rot.y;
    this.mesh.rotation.z = netObj.rot.z;
    
};

// =============================================================================
//  The Client.
// =============================================================================
var Client = function(){
  
    this.id = null;
    
    this.key_left = false;
    this.key_right = false;
    this.key_up = false;
    this.key_down = false;
    this.jump = false;
    
    this.velocity = new THREE.Vector3();
    
    this.peers = new Object;
    
    // Data needed for reconciliation.
    this.input_sequence_number = 0;
    this.pending_inputs = [];
    
    // Client message queue.
    this.queue = new Queue();
    
        
};

Client.prototype.processInputs = function(){
    
    var input = new Object;
    input.input_sequence_number = this.input_sequence_number++;
    input.id = this.id;
    
    if(this.key_up){
        input.key_up = true;
    } else {
        input.key_up = false;
    }
    
    if(this.key_down){
        input.key_down = true;
    } else {
        input.key_down = false;
    }
    
    if(this.key_left){
        input.key_left = true;
    } else {
        input.key_left = false;
    }
    
    if(this.key_right){
        input.key_right = true;
    } else {
        input.key_right = false;
    }
    
    if(this.jump && this.velocity.y === 0){
        input.jump = true;
    } else {
        input.jump = false;
    }
    
    // This may or may not be useful...
    input.quat = {
        x:controls.getObject().quaternion.x,
        y:controls.getObject().quaternion.y,
        z:controls.getObject().quaternion.z,
        w:controls.getObject().quaternion.w
    };
    input.rot = {
        x:controls.getObject().rotation.x,
        y:controls.getObject().rotation.y,
        z:controls.getObject().rotation.z
    };
    
    // Send this input to the server for processing
    socket.emit('client_input', input);
    
    // Do client-side prediction.
    this.applyInput(input);
    
    // Save this input for later reconciliation.
    this.pending_inputs.push(input);

};

Client.prototype.applyInput = function(input){
  
    if(input.jump){
        this.velocity.y += 350;
        this.jump = false;
    }
    
    this.velocity.x -= this.velocity.x * 10.0 * dt;
    this.velocity.z -= this.velocity.z * 10.0 * dt;
    this.velocity.y -= 9.8 * 100.0 * dt; // 100.0 = mass

    if ( input.key_up ) this.velocity.z -= 400.0 * dt;
    if ( input.key_down ) this.velocity.z += 400.0 * dt;
    if ( input.key_left ) this.velocity.x -= 400.0 * dt;
    if ( input.key_right ) this.velocity.x += 400.0 * dt;

    controls.getObject().translateX( this.velocity.x * dt );
    controls.getObject().translateY( this.velocity.y * dt );
    controls.getObject().translateZ( this.velocity.z * dt );

    if ( controls.getObject().position.y < 10 ) {
        this.velocity.y = 0;
        controls.getObject().position.y = 10;
    }
        
};

// Find the position each player is facing relative to
// the current player camera position and display the 
// correct texture on the player billboard, animate texture
Client.prototype.animatePeers = function(){

    var animation_speed = 1000 * dt;
    
    for(var peer_id in this.peers){
        
        var peer = this.peers[peer_id];
        
        var a = new THREE.Vector3();
        a.subVectors(controls.getObject().position, peer.mesh.position);
        a.normalize();

        var b = new THREE.Vector3(0,0,1);
        b.applyQuaternion(peer.mesh.quaternion);
        b.normalize();

        var theta = Math.acos(a.dot(b)) * (180/Math.PI);
        if(a.x * a.z < 0){
            theta = 360.0 - theta;
        }
        
        //console.log(theta);
        
        if((theta > 0 && theta <= 22.5) || (theta > 337.5 && theta <= 359.99)){//south
            peer.direction = 'south';
            peer.billboard.material.map = peer.textures.s;
            peer.billboard.needsUpdate = true;
            peer.animations.s.update(animation_speed);
        }
        else if(theta > 292.5 && theta <= 337.5){//south east
            peer.direction = 'south east';
            peer.billboard.material.map = peer.textures.se;
            peer.billboard.needsUpdate = true;
            peer.animations.se.update(animation_speed);
        }
        else if((theta < 292.5 && theta >= 270) || (theta > 90 && theta <= 112.5)){//east
            peer.direction = 'east';
            peer.billboard.material.map = peer.textures.e;
            peer.billboard.needsUpdate = true;
            peer.animations.e.update(animation_speed);
        }
        else if(theta > 112.5 && theta <= 157.5){//northeast
            peer.direction = 'northeast';
            peer.billboard.material.map = peer.textures.ne;
            peer.billboard.needsUpdate = true;
            peer.animations.ne.update(animation_speed);
        }
        else if(theta > 157.5 && theta <= 202.5){//north
            peer.direction = 'north';
            peer.billboard.material.map = peer.textures.n;
            peer.billboard.needsUpdate = true;
            peer.animations.n.update(animation_speed);
        }
        else if(theta > 202.5 && theta <= 247.5){//northwest
            peer.direction = 'northwest';
            peer.billboard.material.map = peer.textures.nw;
            peer.billboard.needsUpdate = true;
            peer.animations.nw.update(animation_speed);
        }
        else if((theta > 67.5 && theta <= 89.99) || (theta > 247.5 && theta <= 269.99)){//west
            peer.direction = 'west';
            peer.billboard.material.map = peer.textures.w;
            peer.billboard.needsUpdate = true;
            peer.animations.w.update(animation_speed);
        }
        else if(theta > 22.5 && theta <= 67.5){//southwest
            peer.direction = 'southwest';
            peer.billboard.material.map = peer.textures.sw;
            peer.billboard.needsUpdate = true;
            peer.animations.sw.update(animation_speed);
        }

        peer.billboard.lookAt(controls.getObject().position);

    }
};

Client.prototype.updatePosition = function(netObj){
    
    controls.getObject().position.x = netObj.position.x;
    controls.getObject().position.y = netObj.position.y;
    controls.getObject().position.z = netObj.position.z;
    
};

Client.prototype.disconnectPeer = function(id){
    
    var selectedObject = scene.getObjectByName(this.peers[id].billboard.name);
    scene.remove(selectedObject);
    
    var selectedObject = scene.getObjectByName(this.peers[id].mesh.name);
    scene.remove(selectedObject);
    
    delete(this.peers[id]);
        
};

Client.prototype.processServerUpdates = function(){
    while(true){
     
        var update = this.queue.receive();
        
        if(!update){
            break;
        }
        
        for(var id in update.payload){
            
            var server_state = update.payload[id];
            
            if(id === this.id){ // This message pertains to the client object
                
                // Set user's current state equal to the state processed by the server
                this.updatePosition(server_state);
                
                // Server Reconciliation. Re-apply all the inputs not yet processed by the server
                var i = 0;
                while(i < this.pending_inputs.length){
                    
                    var input = this.pending_inputs[i];
                    if(input.input_sequence_number <= server_state.last_processed_input){
                        
                        // Already processed. Remove
                        this.pending_inputs.splice(i, 1);
                        
                    } else {
                        
                        // Not processed by server yet. Re-apply.
                        this.applyInput(input);
                        i++;
                        
                    }
                    
                }
                
            } else { // This is a peer update
                
                this.peers[id].updatePosition(server_state);
                
            }
            
        }
            
    }        
};

Client.prototype.update = function(){
    
    this.processServerUpdates();
    this.processInputs();
    this.animatePeers();

};

</script>
<script>
    
    // =============================================================================
    //  Globals
    // =============================================================================
    var camera, 
        scene, 
        renderer,
        geometry,
        material,
        mesh,
        controls,
        blocker = document.getElementById( 'blocker' ),
        instructions = document.getElementById( 'instructions' ),
        controlsEnabled = false,
        prevTime = performance.now(),
        clock = new THREE.Clock();

    var t = 0.0;
    var dt = 0.01;
    var currentTime = (+new Date()) / 1000.0;
    var accumulator = 0.0;



    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);

    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xffffff, 0, 750);

    var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
    light.position.set(0.5, 1, 0.75);
    scene.add(light);

    controls = new THREE.PointerLockControls(camera);
    scene.add(controls.getObject());


    //FLOOR
    geometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
    geometry.rotateX( - Math.PI / 2 );
    for (var i = 0, l = geometry.vertices.length; i < l; i ++) {
        var vertex = geometry.vertices[ i ];
        vertex.x += Math.random() * 20 - 10;
        vertex.y += Math.random() * 2;
        vertex.z += Math.random() * 20 - 10;
    }
    for (var i = 0, l = geometry.faces.length; i < l; i ++) {
        var face = geometry.faces[ i ];
        face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
    }
    material = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    //END FLOOR

    // Create renderer
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0xffffff);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);




    var client = new Client();
    //client.addPeer({id:'test_id'});

    var socket = io('http://local.three.js:3000');//change the domain to yours
    
    socket.on('successful_connection', function(netObj){
        
        client.id = netObj.id;
        client.updatePosition(netObj);

        // Run the main game loop as fast as we can
        setInterval(function(){
            mainLoop();
        }, 0);

    });
    
    socket.on('new_player_connection', function(netObj){
        if(netObj.id !== client.id){

            client.peers[netObj.id] = new Peer(netObj);
        
        }
    });
    
    socket.on('connected_players', function(netObj){
        for(var id in netObj){
            if(id !== client.id){
                client.peers[id] = new Peer(netObj[id]);
            }
        }
    });
    
    socket.on('player_disconnect', function(id){
        client.disconnectPeer(id);
    });
    
    socket.on('server_state', function(server_state){
        //console.log(server_state);
        client.queue.send(server_state);
    });
    

    function mainLoop(){  
        
        var newTime = (+new Date()) / 1000.0;
        var frameTime = ((newTime - currentTime) > 0.25) ? 0.25 : (newTime - currentTime);
        currentTime = newTime;

        accumulator += frameTime;
        while(accumulator >= dt){

            client.update();

            //this.previous_x = this.current_x;

            t += dt;
            accumulator -= dt;       

        }

        //var alpha = accumulator / dt;

        // Interpolate position of client object
        //this.render_x = this.lerp(this.current_x, this.previous_x, alpha); 
        //this.render_x = this.current_x;

        
        renderer.render(scene, camera);
        
    }
        


    function testFunction(){
        
//        mesh = client.peers['test_id'].mesh;
//        mesh_quat = mesh.quaternion;
//        
//        mesh.quaternion.set(0, mesh_quat.y + .05, 0, mesh_quat.w + .05);
//        
//        console.log(mesh_quat);
        
        //console.log(client.peers['test_id'].mesh.rotation.y);
        //console.log(client.peers['test_id'].direction);
        
        //client.peers['test_id'].mesh.rotateY(.5);

        
        //console.log('Pressed Enter...');
        //console.log(client.peers['test_id'].mesh.quaternion);
        //console.log(controls.getObject().position);
        //console.log(client.peers['test_id'].mesh.rotation);
        //console.log(controls.getObject().quaternion.w);
        
        //console.log(controls.getDirection());
        
//        console.log(controls.getObject().quaternion.x);
//        console.log(controls.getObject().quaternion.y);
//        console.log(controls.getObject().quaternion.z);
//        console.log(controls.getObject().quaternion.w);

        console.log(controls.getObject().rotation.x);
        console.log(controls.getObject().rotation.y);
        console.log(controls.getObject().rotation.z);


        
    }
</script>
        

<script src="/src/key_controls.js"></script>
<script src="/src/window_resize.js"></script>
        
</body>
</html>