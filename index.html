<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <link rel="stylesheet" href="/css/custom.css" media="all"/>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.7/socket.io.min.js"></script>
        
    </head>
    <body>
        <div id="blocker">
            <div id="instructions">
<!--                <span style="font-size:40px">Basic WASD/Mouse Movement</span>
                <br/>
                <span style="font-size:30px">Click to start</span>
                <br />
                (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)-->
            </div>
        </div>




        <script src="/libs/three.js"></script>
        <script src="/libs/PointerLockControls.js"></script>
        
        
        <script src="/src/verify_pointerlock.js"></script>
        <script src="/src/TextureAnimator.js"></script>
<script>
// =============================================================================
//  Message queue.
// =============================================================================
var Queue = function() {
    this.updates = [];
};

Queue.prototype.send = function(update) {
    this.updates.push({recv_ts: +new Date(),payload:update});
};

Queue.prototype.receive = function() {
  for (var i = 0; i < this.updates.length; i++) {
      var update = this.updates[i];
      this.updates.splice(i, 1);
      return update;
  }
};

// =============================================================================
//  Peer object
// =============================================================================
var Peer = function(netObj) {

    this.textures = {
        s:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/s.png'),
        se:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/se.png'),
        e:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/e.png'),
        ne:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/ne.png'),
        n:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/n.png'),
        nw:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/nw.png'),
        w:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/w.png'),
        sw:new THREE.ImageUtils.loadTexture('/assets/textures/player_0/sw.png')
    };

    this.animations = {
        s:new TextureAnimator(this.textures.s, 4, 1, 4, 160),
        se:new TextureAnimator(this.textures.se, 4, 1, 4, 160),
        e:new TextureAnimator(this.textures.e, 4, 1, 4, 160),
        ne:new TextureAnimator(this.textures.ne, 4, 1, 4, 160),
        n:new TextureAnimator(this.textures.n, 4, 1, 4, 160),
        nw:new TextureAnimator(this.textures.nw, 4, 1, 4, 160),
        w:new TextureAnimator(this.textures.w, 4, 1, 4, 160),
        sw:new TextureAnimator(this.textures.sw, 4, 1, 4, 160)
    };

    this.billboard_mat = new THREE.MeshBasicMaterial({map: this.textures.n,  transparent:true});
    this.billboard_geom = new THREE.PlaneGeometry(14, 14, 1, 1);
    this.billboard = new THREE.Mesh(this.billboard_geom, this.billboard_mat);
    this.billboard.name = netObj.id + '_billboard';
    this.billboard.rotation.set(0,0,0);
    
    
    this.material = new THREE.MeshBasicMaterial({transparent:true, opacity:0.0});
    this.geometry = new THREE.PlaneGeometry(14, 14, 1, 1);
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.name = netObj.id + '_mesh';
    this.mesh.rotation.set(0,0,0);

    this.billboard.position.set(netObj.position.x,netObj.position.y,netObj.position.z);
    scene.add(this.billboard);

    this.mesh.position.set(netObj.position.x,netObj.position.y,netObj.position.z);
    scene.add(this.mesh);
    
    this.direction = '';

};

Peer.prototype.updatePosition = function(netObj){
    
    this.billboard.position.x = netObj.position.x;
    this.billboard.position.y = netObj.position.y;
    this.billboard.position.z = netObj.position.z;
    
    this.mesh.position.x = netObj.position.x;
    this.mesh.position.y = netObj.position.y;
    this.mesh.position.z = netObj.position.z;
    

    this.mesh.quaternion.set(netObj.quat.x, netObj.quat.y, netObj.quat.z, netObj.quat.w);
    this.mesh.quaternion.normalize();
    
};

// =============================================================================
//  The Client.
// =============================================================================
var Client = function(){
  
    this.id = null;
    
    this.key_left = false;
    this.key_right = false;
    this.key_up = false;
    this.key_down = false;
    this.jump = false;
    
    this.velocity = new THREE.Vector3();
    
    this.peers = new Object;
    
    // Data needed for reconciliation.
    this.input_sequence_number = 0;
    this.pending_inputs = [];
    
    // Client message queue.
    this.queue = new Queue();
    
        
};

Client.prototype.processInputs = function(){
    
    var input = new Object;
    input.input_sequence_number = this.input_sequence_number++;
    input.id = this.id;
    
    if(this.key_up){
        input.key_up = true;
    } else {
        input.key_up = false;
    }
    
    if(this.key_down){
        input.key_down = true;
    } else {
        input.key_down = false;
    }
    
    if(this.key_left){
        input.key_left = true;
    } else {
        input.key_left = false;
    }
    
    if(this.key_right){
        input.key_right = true;
    } else {
        input.key_right = false;
    }
    
    if(this.jump && this.velocity.y === 0){
        input.jump = true;
    } else {
        input.jump = false;
    }
    
    input.quat = {
        x:controls.getObject().quaternion.x,
        y:controls.getObject().quaternion.y,
        z:controls.getObject().quaternion.z,
        w:controls.getObject().quaternion.w
    };
    input.rot = {
        x:controls.getObject().rotation.x,
        y:controls.getObject().rotation.y,
        z:controls.getObject().rotation.z
    };
    
    // Send this input to the server for processing
    socket.emit('client_input', input);
    
    // Do client-side prediction.
    this.applyInput(input);
    
    // Save this input for later reconciliation.
    this.pending_inputs.push(input);

};

Client.prototype.applyInput = function(input){
  
    if(input.jump){
        this.velocity.y += 350;
        this.jump = false;
    }
    
    this.velocity.x -= this.velocity.x * 10.0 * deltaTime;
    this.velocity.z -= this.velocity.z * 10.0 * deltaTime;
    this.velocity.y -= 9.8 * 100.0 * deltaTime; // 100.0 = mass

    if ( input.key_up ) this.velocity.z -= 400.0 * deltaTime;
    if ( input.key_down ) this.velocity.z += 400.0 * deltaTime;
    if ( input.key_left ) this.velocity.x -= 400.0 * deltaTime;
    if ( input.key_right ) this.velocity.x += 400.0 * deltaTime;

    controls.getObject().translateX( this.velocity.x * deltaTime );
    controls.getObject().translateY( this.velocity.y * deltaTime );
    controls.getObject().translateZ( this.velocity.z * deltaTime );

    if ( controls.getObject().position.y < 10 ) {
        this.velocity.y = 0;
        controls.getObject().position.y = 10;
    }
        
};

// Find the position each player is facing relative to
// the current player camera position and display the 
// correct texture on the player billboard, animate texture
Client.prototype.animatePeers = function(){

    var animation_speed = 1000 * deltaTime;
    
    for(var peer_id in this.peers){
        
        var peer = this.peers[peer_id];
        
        var view = new THREE.Vector3();
        view.subVectors(controls.getObject().position, peer.mesh.position);

        var inverse = peer.mesh.quaternion.clone();
        inverse.inverse();

        view.applyQuaternion(inverse);

        var angle = Math.round(Math.atan2(view.x, view.z) * 4/Math.PI);

        if(angle === 0 || angle === -0){// North
            peer.billboard.material.map = peer.textures.n;
            peer.billboard.needsUpdate = true;
            peer.animations.n.update(animation_speed);
        }
        else if(angle === -1){// Northwest
            peer.billboard.material.map = peer.textures.nw;
            peer.billboard.needsUpdate = true;
            peer.animations.nw.update(animation_speed);
        }
        else if(angle === -2){// West
            peer.billboard.material.map = peer.textures.w;
            peer.billboard.needsUpdate = true;
            peer.animations.w.update(animation_speed);
        }
        else if(angle === -3){// Southwest
            peer.billboard.material.map = peer.textures.sw;
            peer.billboard.needsUpdate = true;
            peer.animations.sw.update(animation_speed);
        }
        else if(angle === 4 || angle === -4){// South
            peer.billboard.material.map = peer.textures.s;
            peer.billboard.needsUpdate = true;
            peer.animations.s.update(animation_speed);
        }
        else if(angle === 3){// Southeast
            peer.billboard.material.map = peer.textures.se;
            peer.billboard.needsUpdate = true;
            peer.animations.se.update(animation_speed);
        }
        else if(angle === 2){// East
            peer.billboard.material.map = peer.textures.e;
            peer.billboard.needsUpdate = true;
            peer.animations.e.update(animation_speed);
        }
        else if(angle === 1){// Northeast
            peer.billboard.material.map = peer.textures.ne;
            peer.billboard.needsUpdate = true;
            peer.animations.ne.update(animation_speed);
        }

        peer.billboard.lookAt(controls.getObject().position);

    }
};

Client.prototype.updatePosition = function(netObj){
    
    controls.getObject().position.x = netObj.position.x;
    controls.getObject().position.y = netObj.position.y;
    controls.getObject().position.z = netObj.position.z;
    
};

Client.prototype.disconnectPeer = function(id){
    
    var selectedObject = scene.getObjectByName(this.peers[id].billboard.name);
    scene.remove(selectedObject);
    
    var selectedObject = scene.getObjectByName(this.peers[id].mesh.name);
    scene.remove(selectedObject);
    
    delete(this.peers[id]);
        
};

Client.prototype.processServerUpdates = function(){
    while(true){
     
        var update = this.queue.receive();
        
        if(!update){
            break;
        }
        
        for(var id in update.payload){
            
            var server_state = update.payload[id];
            
            if(id === this.id){ // This message pertains to the client object
                
                // Set user's current state equal to the state processed by the server
                this.updatePosition(server_state);
                
                // Server Reconciliation. Re-apply all the inputs not yet processed by the server
                var i = 0;
                while(i < this.pending_inputs.length){
                    
                    var input = this.pending_inputs[i];
                    if(input.input_sequence_number <= server_state.last_processed_input){
                        
                        // Already processed. Remove
                        this.pending_inputs.splice(i, 1);
                        
                    } else {
                        
                        // Not processed by server yet. Re-apply.
                        this.applyInput(input);
                        i++;
                        
                    }
                    
                }
                
            } else { // This is a peer update
                
                this.peers[id].updatePosition(server_state);
                
            }
            
        }
            
    }        
};

Client.prototype.update = function(){
    
    this.processServerUpdates();
    this.processInputs();
    this.animatePeers();

};

</script>
<script>
    
    // =============================================================================
    //  Globals
    // =============================================================================
    var camera, 
    scene, 
    renderer,
    controls,
    blocker = document.getElementById( 'blocker' ),
    instructions = document.getElementById( 'instructions' ),
    controlsEnabled = false,
    runTime = 0.0,
    deltaTime = 0.01,
    currentTime = (+new Date()) / 1000.0,
    accumulator = 0.0;
    
    // Create camera object: PerspectiveCamera( fov, aspect, near, far )
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);

    // Create scene object, add fog to scene: Fog( hex, near, far )
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xffffff, 0, 750);

    // Create hemisphere light object, set it's position, add it to the scene: HemisphereLight(skyColorHex, groundColorHex, intensity)
    var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
    light.position.set(0.5, 1, 0.75);
    scene.add(light);
    
    // Create the controls object, add it to the scene. This is the player object on the client.
    controls = new THREE.PointerLockControls(camera);
    scene.add(controls.getObject());


    // Add floor to scene
    var floor_geometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
    floor_geometry.rotateX( - Math.PI / 2 );
    for (var i = 0, l = floor_geometry.vertices.length; i < l; i ++) {
        var vertex = floor_geometry.vertices[ i ];
        vertex.x += Math.random() * 20 - 10;
        vertex.y += Math.random() * 2;
        vertex.z += Math.random() * 20 - 10;
    }
    for (var i = 0, l = floor_geometry.faces.length; i < l; i ++) {
        var face = floor_geometry.faces[ i ];
        face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
    }
    var floor_material = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
    var floor_mesh = new THREE.Mesh(floor_geometry, floor_material);
    scene.add(floor_mesh);
    

    // Create renderer
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0xffffff);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


    // Create client, socket, and socket events
    var client = new Client();
    var socket = io('http://local.three.js:3000');//change the domain to yours
    
    socket.on('successful_connection', function(netObj){
        
        client.id = netObj.id;
        client.updatePosition(netObj);

        // Run the main game loop as fast as we can
        setInterval(function(){
            mainLoop();
        }, 0);

    });
    
    socket.on('new_player_connection', function(netObj){
        if(netObj.id !== client.id){
            client.peers[netObj.id] = new Peer(netObj);
        }
    });
    
    socket.on('connected_players', function(netObj){
        for(var id in netObj){
            if(id !== client.id){
                client.peers[id] = new Peer(netObj[id]);
            }
        }
    });
    
    socket.on('player_disconnect', function(id){
        client.disconnectPeer(id);
    });
    
    socket.on('server_state', function(server_state){
        client.queue.send(server_state);
    });
    
    // Main game loop
    function mainLoop(){  
        
        var newTime = (+new Date()) / 1000.0;
        var frameTime = ((newTime - currentTime) > 0.25) ? 0.25 : (newTime - currentTime);
        currentTime = newTime;
        
        // Physics/Game logic 
        accumulator += frameTime;
        while(accumulator >= deltaTime){

            client.update();

            runTime += deltaTime;
            accumulator -= deltaTime;       

        }
        
        // Render stuff and such
        
        // Interpolate client object to remove the stuttering caused by
        // unpredictable number of physics loops
        
        // Interpolate peer positions

        
        renderer.render(scene, camera);
        
    }
        

    // This function is used to test various things. It is run whenever the enter button
    // is pressed
    function testFunction(){
        

        
    }
</script>
        

<script src="/src/key_controls.js"></script>
<script src="/src/window_resize.js"></script>
        
</body>
</html>